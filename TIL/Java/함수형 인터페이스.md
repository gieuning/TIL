# 함수형 인터페이스
> 함수형 인터페이스는 오직 하나의 추상 메서드만을 가지는 인터페이스를 말한다. 
이 인터페이스는 람다식 또는 메서드 참조의 대상이 될 수 있어 Java에서 함수형 프로그래밍 스타일을 가능하게 한다.
참고로 람다는 클래스, 추상 클래스에는 할당할 수 없으며, 오직 단일 추상 메서드를 가지는 인터페이스에만 할당할 수 있다.

---

단일 추상 메서드를 **SAM(Single Abstract Method)**이라 한다. 

## ✅ 함수형 인터페이스의 특징
- @FunctionalInterface 애너테이션을 붙여 명시적으로 선언할 수 있음
→ 컴파일러가 하나의 추상 메서드만 존재하는지 확인해줌
- Object 클래스에서 물려받은 메서드는 포함되지 않음
- 람다식의 대상이 되기 때문에 매우 유용함

---


```java
@FunctionalInterface
public interface MyFunction {
    int apply(int a, int b); // 단 하나의 추상 메서드
}
```

```java
MyFunction add = (a, b) -> a + b;
System.out.println(add.apply(10, 20)); // 30
```

---


## ❗ @FunctionalInterface는 꼭 붙여야 할까?
선택사항이지만 붙여두면 실수로 추상 메서드를 두 개 이상 만들었을 때 컴파일 에러를 통해 알려주므로 작성하는 것이 좋다.

---

## ✅ 자바에서 제공하는 주요 함수형 인터페이스

| 인터페이스 | 추상 메서드         | 설명                                |
|------------|---------------------|-------------------------------------|
| `Runnable` | `void run()`        | 매개변수 없고 반환값 없는 작업     |
| `Callable<T>` | `T call()`       | 매개변수 없고 반환값 있는 작업     |
| `Supplier<T>` | `T get()`        | 값을 공급 (매개변수 X, 반환 O)     |
| `Consumer<T>` | `void accept(T t)`| 값을 소비 (매개변수 O, 반환 X)     |
| `Function<T,R>` | `R apply(T t)` | 하나의 값을 받아 결과 반환         |
| `Predicate<T>` | `boolean test(T t)` | 값을 받아 조건 판단 (true/false) |
| `BiFunction<T,U,R>` | `R apply(T t, U u)` | 두 개의 입력값을 받아 결과 반환 |

---

## ✅ 왜 사용할까?
- 람다식을 사용하여 코드를 간결하게 작성 가능
- 함수형 프로그래밍을 지원
- 스트림 API, 컬렉션 조작에서 자주 사용됨
- 병렬 처리, 비동기 처리에서도 유용

---


## 📝 마무리 요약
- 함수형 인터페이스는 추상 메서드가 하나뿐인 인터페이스
- 람다식과 메서드 참조를 사용하려면 꼭 필요
- @FunctionalInterface로 선언하면 안전하게 작성 가능
- Java에서 기본 제공하는 인터페이스도 다양하게 활용 가능


---

